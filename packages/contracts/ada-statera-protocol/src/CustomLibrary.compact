module CustomLibrary {
    import CompactStandardLibrary;
    export { MintMetadata, StakeMetadata, AdminMetadata, calculateHFactor, DivisionFunction, generateUserId, getMintMetadata, hashMintMetadata, getStakeMetadata, hashStakeMetadata, getAdminMetadata, hashAdminMetadata, generateAdminId, ComplianceToken, KYCTokenData, ValidityRange, getStakePoolCoin, hashStakePoolCoin, getReservePoolCoin, hashReservePoolCoin, isAdmin, isSuperAdmin, createEmptyAdmins};

    /* Structure for Private state - Depositors */
    struct MintMetadata {
        collateral: Uint<64>;
        debt: Uint<64>;
    }

    /* Structure for Private state - Stakers */
    struct StakeMetadata {
        effectiveBalance: Uint<32>;
        stakeReward: Uint<64>;
        entry_ADA_SUSD_index: Uint<128>;
        entry_scale_factor: Uint<32>;
    }

    /* Structure for Private state - Admin */
    struct AdminMetadata {
        protocolFeePool: Uint<128>;
        super_admin: Bytes<32>;
        admins: Vector<10, Bytes<32>>;
        admin_count: Uint<8>;
    }

    struct KYCTokenData {
        // User's DID identifier
        did: Bytes<32>;
        // User's PublicKey
        userPk: Bytes<32>;
        // Oracle public key
        oraclePk: Bytes<32>;
        // Validity range for the token
        validityRange: ValidityRange;
    }

    struct ValidityRange {
        duration: Uint<64>;
        creationDate: Uint<64>;
    }

    struct ComplianceToken {
        tokenData: KYCTokenData;
        // Signature from oracle to verify authenticity of the token
        oracleSignature: Bytes<32>;
    }

    witness division(divident: Uint<64>, divisor:Uint<64>): [Uint<64>, Uint<64>];
    witness get_mintmetadata_private_state(): MintMetadata;
    witness get_stakemetadata_private_state(): StakeMetadata;
    witness get_adminmetadata_private_state(): AdminMetadata;
    witness get_stakepoolcoin_private_state(): QualifiedCoinInfo;
    witness get_reservepoolcoin_private_state(): QualifiedCoinInfo;
    witness admin_secret(): Bytes<32>;
 
    circuit calculateHFactor(collateralAmount: Uint<64>, amountToMint: Uint<64>, liquidationThreshold: Uint<8>): Uint<128>{
        const percentageDivisor: Uint<64> = 100;
        const healthFactor = DivisionFunction((collateralAmount * liquidationThreshold) as Uint<64>, (amountToMint * percentageDivisor) as Uint<64>);
        return healthFactor;
    }

    circuit DivisionFunction(dividend: Uint<64>, divisor: Uint<64>): Uint<128> {
        assert (divisor != 0, "Invalid divisor provided");
        
        const [quotient, remainder] = disclose(division(dividend, divisor));
        assert (remainder < divisor, "Reminder error");
        assert (quotient * divisor + remainder == dividend, "Invald divison result");
        return quotient;
    }

    circuit generateUserId(sk: Bytes<32>): Bytes<32>{
        // Use commitment instead of hash for better privacy
        // Commit to user's public key using their secret key as randomness
        return persistentCommit<Bytes<32>>(ownPublicKey().bytes, sk);
    }

    circuit generateAdminId(sk: Bytes<32>): Bytes<32>{
        return persistentHash<Vector<2, Bytes<32>>>(
            [
                pad(32, "susd:admin"),
                persistentHash<Vector<2, Bytes<32>>>(
                    [sk, kernel.self().bytes]
                )
            ]
        );
    }

    circuit getMintMetadata(): MintMetadata{
        const {debt, collateral} = disclose(get_mintmetadata_private_state());
        return MintMetadata {
            collateral,
            debt
        };
    } 

    circuit hashMintMetadata (metadata: MintMetadata, randomizer: Bytes<32>): Bytes<32> {
        return persistentCommit<MintMetadata>(metadata, randomizer);
    }

    circuit getStakeMetadata(): StakeMetadata{
        const {effectiveBalance, stakeReward, entry_ADA_SUSD_index, entry_scale_factor} = disclose(get_stakemetadata_private_state());
        return StakeMetadata {
            effectiveBalance,
            stakeReward,
            entry_ADA_SUSD_index,
            entry_scale_factor
        };
    }

    circuit hashStakeMetadata (metadata: StakeMetadata, randomizer: Bytes<32>): Bytes<32> {
        return persistentCommit<StakeMetadata>(metadata, randomizer);
    }

    circuit getAdminMetadata(): AdminMetadata{
        const {protocolFeePool, super_admin, admins, admin_count} = disclose(get_adminmetadata_private_state());
        return AdminMetadata {
            protocolFeePool,
            super_admin,
            admins,
            admin_count
        };
    }

    circuit hashAdminMetadata (metadata: AdminMetadata, randomizer: Bytes<32>): Bytes<32> {
        return persistentCommit<AdminMetadata>(metadata, randomizer);
    }

    circuit getStakePoolCoin(): QualifiedCoinInfo{
        const poolCoin = disclose(get_stakepoolcoin_private_state());
        return poolCoin;
    }

    circuit hashStakePoolCoin (poolCoin: QualifiedCoinInfo): Bytes<32> {
        return persistentHash<QualifiedCoinInfo>(poolCoin);
    }

    circuit getReservePoolCoin(): QualifiedCoinInfo{
        const poolCoin = disclose(get_reservepoolcoin_private_state());
        return poolCoin;
    }

    circuit hashReservePoolCoin (poolCoin: QualifiedCoinInfo): Bytes<32> {
        return persistentHash<QualifiedCoinInfo>(poolCoin);
    }

    // Helper to create empty admins vector
    circuit createEmptyAdmins(): Vector<10, Bytes<32>> {
        const zero: Bytes<32> = pad(32, "");
        return [zero, zero, zero, zero, zero, zero, zero, zero, zero, zero];
    }

    // Check if current user is super admin
    circuit isSuperAdmin(metadata: AdminMetadata): Boolean {
        return ownPublicKey().bytes == metadata.super_admin;
    }

    // Check if current user is an admin (super admin or in admins list)
    circuit isAdmin(metadata: AdminMetadata): Boolean {
        const currentUser = ownPublicKey().bytes;

        // Check if super admin
        if (currentUser == metadata.super_admin) {
            return true;
        }

        // Check if in admins list (manual unrolling for max 10 admins)
        if (metadata.admin_count > 0 && currentUser == metadata.admins[0]) { return true; }
        if (metadata.admin_count > 1 && currentUser == metadata.admins[1]) { return true; }
        if (metadata.admin_count > 2 && currentUser == metadata.admins[2]) { return true; }
        if (metadata.admin_count > 3 && currentUser == metadata.admins[3]) { return true; }
        if (metadata.admin_count > 4 && currentUser == metadata.admins[4]) { return true; }
        if (metadata.admin_count > 5 && currentUser == metadata.admins[5]) { return true; }
        if (metadata.admin_count > 6 && currentUser == metadata.admins[6]) { return true; }
        if (metadata.admin_count > 7 && currentUser == metadata.admins[7]) { return true; }
        if (metadata.admin_count > 8 && currentUser == metadata.admins[8]) { return true; }
        if (metadata.admin_count > 9 && currentUser == metadata.admins[9]) { return true; }

        return false;
    }

}
