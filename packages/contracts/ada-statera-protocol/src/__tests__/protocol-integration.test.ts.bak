import { describe, it, expect, beforeEach } from 'vitest';
import {
  createStateraTestFixture,
  createAdminPrivateState,
  createPrivateStateForWallet,
  createPrivateStateWithDepositorLeaf,
  getPrivateStateAfterDeposit,
  getPrivateStateAfterStake,
  updateAllBalances,
  printAllBalances,
  createMockCoin,
  createCollateralCoin,
  createSUSDCoin,
  createMockComplianceToken,
  createMockOraclePk,
  createUserId,
  createMetadataHash,
  createMintCounterCommitment,
  prepareCoinForReceive,
  type StateraTestFixture
} from './test-utils.js';
import { pad, generateNonce } from '@statera/simulator';
import { DebtPositionStatus } from '../managed/adaStateraProtocol/contract/index.cjs';

describe('Ada Statera Protocol - Full Integration Tests', () => {
  let fixture: StateraTestFixture;

  beforeEach(() => {
    fixture = createStateraTestFixture(5);
  });

  describe('Complete Deposit → Mint → Repay Flow', () => {
    it('should allow user to deposit collateral, mint sUSD, and repay debt', () => {
      const { simulator, adminWallet, userWallets, collateralTokenType, sSUSDTokenType } = fixture;
      const user = userWallets[0];
      const oraclePk = createMockOraclePk();

      // Step 1: Admin adds trusted oracle
      simulator
        .as(createAdminPrivateState(simulator, adminWallet))
        .executeImpureCircuit('addTrustedOracle', oraclePk);

      // Step 2: Create a mock compliance token (KYC)
      const complianceToken = createMockComplianceToken(user.coinPublicKey, oraclePk);

      // Step 3: User deposits collateral
      const depositAmount = 1000n;
      const mockCoin = createCollateralCoin(depositAmount);

      // Prepare the coin for receive() - adds it to ZSwap inputs
      prepareCoinForReceive(simulator, mockCoin, collateralTokenType);

      // Execute deposit circuit - MUST pass user's coinPublicKey for ownPublicKey() to work
      simulator
        .as(createPrivateStateForWallet(user), user.coinPublicKey)
        .executeImpureCircuit(
          'depositToCollateralPool',
          mockCoin,
          depositAmount,
          complianceToken,
          true // isNewDepositor
        );

      // Step 4: User mints sUSD (at 70% LVT, can mint up to 700 sUSD from 1000 ADA)
      const mintAmount = 500n;

      // After deposit, reconstruct the depositor leaf that was created
      // MUST pass user's coinPublicKey so ownPublicKey() returns correct value
      expect(() => {
        simulator
          .as(getPrivateStateAfterDeposit(simulator, user, depositAmount), user.coinPublicKey)
          .executeImpureCircuit('mint_sUSD', mintAmount);
      }).not.toThrow();

      // Step 5: User repays debt
      const repayAmount = 200n;
      const mockSUSDCoin = createSUSDCoin(repayAmount, sSUSDTokenType);

      // Prepare sUSD coin for receive()
      prepareCoinForReceive(simulator, mockSUSDCoin, sSUSDTokenType);

      expect(() => {
        simulator
          .as(createPrivateStateForWallet(user))
          .executeImpureCircuit('repay', mockSUSDCoin, repayAmount);
      }).not.toThrow();
    });
  });

  describe('Stability Pool Operations', () => {
    it('should allow staking to stability pool', () => {
      const { simulator, userWallets, sSUSDTokenType } = fixture;
      const staker = userWallets[0];

      const stakeAmount = 5000n;
      const mockSUSDCoin = createSUSDCoin(stakeAmount, sSUSDTokenType);

      // Prepare sUSD coin for receive()
      prepareCoinForReceive(simulator, mockSUSDCoin, sSUSDTokenType);

      expect(() => {
        simulator
          .as(createPrivateStateForWallet(staker))
          .executeImpureCircuit(
            'depositToStabilityPool',
            mockSUSDCoin,
            true // isNewStaker
          );
      }).not.toThrow();
    });

    it('should check and withdraw stake rewards', () => {
      const { simulator, userWallets, sSUSDTokenType } = fixture;
      const staker = userWallets[0];

      // First stake
      const stakeAmount = 5000n;
      const mockCoin = createSUSDCoin(stakeAmount, sSUSDTokenType);

      // Prepare coin for receive()
      prepareCoinForReceive(simulator, mockCoin, sSUSDTokenType);

      simulator
        .as(createPrivateStateForWallet(staker))
        .executeImpureCircuit('depositToStabilityPool', mockCoin, true);

      // Check rewards - reconstruct staker leaf after deposit
      expect(() => {
        simulator
          .as(getPrivateStateAfterStake(simulator, staker, stakeAmount))
          .executeCircuit('checkStakeReward');
      }).not.toThrow();

      // Withdraw rewards - use staker leaf again
      expect(() => {
        simulator
          .as(getPrivateStateAfterStake(simulator, staker, stakeAmount))
          .executeImpureCircuit('withdrawStakeReward', 100n);
      }).not.toThrow();
    });

    it('should allow withdrawing stake', () => {
      const { simulator, userWallets, sSUSDTokenType } = fixture;
      const staker = userWallets[0];

      // Setup: deposit first
      const stakeAmount = 5000n;
      const mockCoin = createSUSDCoin(stakeAmount, sSUSDTokenType);

      // Prepare coin for receive()
      prepareCoinForReceive(simulator, mockCoin, sSUSDTokenType);

      simulator
        .as(createPrivateStateForWallet(staker))
        .executeImpureCircuit('depositToStabilityPool', mockCoin, true);

      // Withdraw - reconstruct staker leaf after deposit
      expect(() => {
        simulator
          .as(getPrivateStateAfterStake(simulator, staker, stakeAmount))
          .executeImpureCircuit('withdrawStake', 1000n);
      }).not.toThrow();
    });
  });

  describe('Liquidation Flow', () => {
    it('should liquidate under-collateralized position', () => {
      const { simulator, adminWallet, userWallets, collateralTokenType, sSUSDTokenType } = fixture;
      const targetUser = userWallets[0];  // User whose position will be liquidated
      const staker = userWallets[1];      // Staker providing funds to stability pool
      const liquidator = userWallets[2];  // Liquidator executing the liquidation
      const oraclePk = createMockOraclePk();

      // Setup: Add oracle
      simulator
        .as(createAdminPrivateState(simulator, adminWallet))
        .executeImpureCircuit('addTrustedOracle', oraclePk);

      // Step 1: Target user deposits collateral and mints sUSD
      const depositAmount = 1000n;
      const mockCoin = createCollateralCoin(depositAmount);
      const complianceToken = createMockComplianceToken(targetUser.coinPublicKey, oraclePk);

      prepareCoinForReceive(simulator, mockCoin, collateralTokenType);

      simulator
        .as(createPrivateStateForWallet(targetUser))
        .executeImpureCircuit(
          'depositToCollateralPool',
          mockCoin,
          depositAmount,
          complianceToken,
          true
        );

      // Mint near max (creating a risky position)
      const mintAmount = 650n; // Close to 70% LVT limit
      simulator
        .as(getPrivateStateAfterDeposit(simulator, targetUser, depositAmount))
        .executeImpureCircuit('mint_sUSD', mintAmount);

      // Step 2: Staker deposits to stability pool (needed for liquidation)
      const stakeAmount = 10000n;
      const stakeCoin = createSUSDCoin(stakeAmount, sSUSDTokenType);
      prepareCoinForReceive(simulator, stakeCoin, sSUSDTokenType);

      simulator
        .as(createPrivateStateForWallet(staker))
        .executeImpureCircuit('depositToStabilityPool', stakeCoin, true);

      // Step 3: Simulate price drop making position undercollateralized
      // In a real scenario, the collateral value would drop below liquidation threshold
      // For testing, we use the commitment/nullifier pattern to liquidate

      // Get the target user's depositor leaf after deposit AND mint
      // After mint, the user has debt, so we need to reconstruct with the new debt amount
      const borrowingFee = (mintAmount * 50n) / 10000n; // 0.5% fee
      const totalDebt = mintAmount + borrowingFee;
      const debtToLiquidate = 300n; // Partial liquidation

      const targetState = createPrivateStateWithDepositorLeaf(targetUser, depositAmount, totalDebt);
      const depositId = targetState.currentDepositorLeaf!.id;

      // Liquidator must provide victim's depositor leaf for commitment/nullifier verification
      expect(() => {
        simulator
          .as(targetState) // Use target user's state to provide their depositor leaf
          .executeImpureCircuit(
            'liquidateDebtPosition',
            depositAmount,      // Total collateral
            totalDebt,          // Total debt
            debtToLiquidate,    // Amount to liquidate
            depositId           // Deposit ID
          );
      }).not.toThrow();
    });
  });

  describe('Redemption Flow', () => {
    it('should allow sUSD redemption for collateral', () => {
      const { simulator, adminWallet, userWallets, sSUSDTokenType } = fixture;
      const redeemer = userWallets[0];
      const oraclePk = createMockOraclePk();

      // Add oracle first
      simulator
        .as(createAdminPrivateState(simulator, adminWallet))
        .executeImpureCircuit('addTrustedOracle', oraclePk);

      // Redeem sUSD for ADA
      const redemptionAmount = 1000n;
      const oraclePrice = 1000000n; // $1.00 per ADA
      const mockSUSDCoin = createSUSDCoin(redemptionAmount, sSUSDTokenType);

      // Prepare coin for receive()
      prepareCoinForReceive(simulator, mockSUSDCoin, sSUSDTokenType);

      expect(() => {
        simulator
          .as(createPrivateStateForWallet(redeemer))
          .executeImpureCircuit(
            'redeemSUSD',
            mockSUSDCoin,
            redemptionAmount,
            oraclePrice,
            oraclePk
          );
      }).not.toThrow();
    });
  });

  describe('Collateral Withdrawal', () => {
    it('should allow withdrawing excess collateral', () => {
      const { simulator, adminWallet, userWallets, collateralTokenType } = fixture;
      const user = userWallets[0];
      const oraclePk = createMockOraclePk();

      // Add oracle
      simulator
        .as(createAdminPrivateState(simulator, adminWallet))
        .executeImpureCircuit('addTrustedOracle', oraclePk);

      // First, user must deposit collateral
      const depositAmount = 2000n;
      const mockCoin = createCollateralCoin(depositAmount);
      const complianceToken = createMockComplianceToken(user.coinPublicKey, oraclePk);

      prepareCoinForReceive(simulator, mockCoin, collateralTokenType);

      simulator
        .as(createPrivateStateForWallet(user))
        .executeImpureCircuit(
          'depositToCollateralPool',
          mockCoin,
          depositAmount,
          complianceToken,
          true
        );

      // Now withdraw excess collateral - reconstruct depositor leaf after deposit
      const withdrawAmount = 100n;
      const oraclePrice = 1000000n; // $1.00 per ADA

      expect(() => {
        simulator
          .as(getPrivateStateAfterDeposit(simulator, user, depositAmount))
          .executeImpureCircuit(
            'withdrawCollateral',
            withdrawAmount,
            oraclePrice,
            oraclePk
          );
      }).not.toThrow();
    });
  });

  describe('Protocol Pause Functionality', () => {
    it('should prevent operations when paused', () => {
      const { simulator, adminWallet, userWallets } = fixture;
      const user = userWallets[0];

      // Pause protocol
      simulator
        .as(createAdminPrivateState(simulator, adminWallet))
        .executeImpureCircuit('togglePause');

      // Attempt to mint (should fail when paused)
      expect(() => {
        simulator
          .as(createPrivateStateForWallet(user))
          .executeImpureCircuit('mint_sUSD', 100n);
      }).toThrow();
    });

    it('should allow operations after unpausing', () => {
      const { simulator, adminWallet } = fixture;

      const adminState = createAdminPrivateState(simulator, adminWallet);

      // Pause
      simulator.as(adminState).executeImpureCircuit('togglePause');

      // Unpause
      expect(() => {
        simulator.as(createAdminPrivateState(simulator, adminWallet))
          .executeImpureCircuit('togglePause');
      }).not.toThrow();
    });
  });

  describe('Multi-User Scenarios', () => {
    it('should handle multiple users with different positions', () => {
      const { simulator, adminWallet, userWallets, collateralTokenType, sSUSDTokenType } = fixture;
      const oraclePk = createMockOraclePk();

      // Setup: Add oracle
      simulator
        .as(createAdminPrivateState(simulator, adminWallet))
        .executeImpureCircuit('addTrustedOracle', oraclePk);

      // User 1: Deposits and mints
      const user1 = userWallets[0];
      const user1Deposit = 2000n;
      const user1Coin = createCollateralCoin(user1Deposit);
      const user1Compliance = createMockComplianceToken(user1.coinPublicKey, oraclePk);

      // Prepare coin for receive()
      prepareCoinForReceive(simulator, user1Coin, collateralTokenType);

      expect(() => {
        simulator
          .as(createPrivateStateForWallet(user1))
          .executeImpureCircuit(
            'depositToCollateralPool',
            user1Coin,
            user1Deposit,
            user1Compliance,
            true
          );
      }).not.toThrow();

      // User 2: Deposits different amount
      const user2 = userWallets[1];
      const user2Deposit = 3000n;
      const user2Coin = createCollateralCoin(user2Deposit);
      const user2Compliance = createMockComplianceToken(user2.coinPublicKey, oraclePk);

      // Prepare coin for receive()
      prepareCoinForReceive(simulator, user2Coin, collateralTokenType);

      expect(() => {
        simulator
          .as(createPrivateStateForWallet(user2))
          .executeImpureCircuit(
            'depositToCollateralPool',
            user2Coin,
            user2Deposit,
            user2Compliance,
            true
          );
      }).not.toThrow();

      // User 3: Stakes in stability pool
      const user3 = userWallets[2];
      const user3Stake = 5000n;
      const user3Coin = createSUSDCoin(user3Stake, sSUSDTokenType);

      // Prepare coin for receive()
      prepareCoinForReceive(simulator, user3Coin, sSUSDTokenType);

      expect(() => {
        simulator
          .as(createPrivateStateForWallet(user3))
          .executeImpureCircuit('depositToStabilityPool', user3Coin, true);
      }).not.toThrow();
    });
  });

  describe('Edge Cases and Validations', () => {
    it('should reject minting below minimum debt', () => {
      const { simulator, userWallets } = fixture;
      const user = userWallets[0];

      // Try to mint less than minimumDebt (100 sUSD from constructor)
      expect(() => {
        simulator
          .as(createPrivateStateForWallet(user))
          .executeImpureCircuit('mint_sUSD', 50n); // Below minimum
      }).toThrow();
    });

    it('should reject withdrawal that would leave position under-collateralized', () => {
      const { simulator, adminWallet, userWallets } = fixture;
      const user = userWallets[0];
      const oraclePk = createMockOraclePk();

      // Add oracle
      simulator
        .as(createAdminPrivateState(simulator, adminWallet))
        .executeImpureCircuit('addTrustedOracle', oraclePk);

      // Try to withdraw more than allowed
      expect(() => {
        simulator
          .as(createPrivateStateForWallet(user))
          .executeImpureCircuit(
            'withdrawCollateral',
            99999n, // Excessive amount
            1000000n,
            oraclePk
          );
      }).toThrow();
    });
  });

  describe('Protocol Fee Accumulation', () => {
    it('should accumulate fees from borrowing and redemption', () => {
      const { simulator, adminWallet, userWallets, collateralTokenType, sSUSDTokenType } = fixture;
      const user = userWallets[0];
      const oraclePk = createMockOraclePk();

      // Setup: Add oracle
      simulator
        .as(createAdminPrivateState(simulator, adminWallet))
        .executeImpureCircuit('addTrustedOracle', oraclePk);

      // User deposits collateral (generates borrowing fee when minting)
      const depositCoin = createCollateralCoin(5000n);
      const userCompliance = createMockComplianceToken(user.coinPublicKey, oraclePk);

      // Prepare deposit coin
      prepareCoinForReceive(simulator, depositCoin, collateralTokenType);

      simulator
        .as(createPrivateStateForWallet(user))
        .executeImpureCircuit(
          'depositToCollateralPool',
          depositCoin,
          5000n,
          userCompliance,
          true
        );

      // Mint sUSD - reconstruct depositor leaf after deposit
      simulator
        .as(getPrivateStateAfterDeposit(simulator, user, 5000n))
        .executeImpureCircuit('mint_sUSD', 1000n);

      // User redeems (generates redemption fee)
      const redeemCoin = createSUSDCoin(500n, sSUSDTokenType);

      // Prepare redeem coin
      prepareCoinForReceive(simulator, redeemCoin, sSUSDTokenType);

      simulator
        .as(createPrivateStateForWallet(user))
        .executeImpureCircuit('redeemSUSD', redeemCoin, 500n, 1000000n, oraclePk);

      // Admin should be able to withdraw accumulated fees
      expect(() => {
        simulator
          .as(createAdminPrivateState(simulator, adminWallet))
          .executeImpureCircuit('withdrawProtocolFees', 10n);
      }).not.toThrow();
    });
  });
});
