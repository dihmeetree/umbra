// TLSNotary Oracle Library
// Provides reusable verification logic for TLSNotary attestations with Schnorr signatures
// Contract builders can import this module to build their own oracle contracts
//
// Usage:
//   import "./TLSNotaryOracle";
//
//   // Your contract needs to define its own ledger state:
//   export ledger trustedNotaries: Set<Field>;
//   export ledger adminPk: CurvePoint;
//
//   // Then use the verification circuits from this module
pragma language_version >= 0.17.0;

module TLSNotaryOracle {
import CompactStandardLibrary;

// Export all public types and circuits
export {
    SignedBytes,
    ChallengeInput,
    Signature,
    verifySignature,
    assertValidSignature,
    verifyAndExtract
};

// Challenge input structure for Schnorr signature verification
struct ChallengeInput {
    r_x: Field;
    r_y: Field;
    pk_x: Field;
    pk_y: Field;
    credentialHash: Bytes<32>;
}

// Schnorr signature (r point, s scalar)
struct Signature {
    r: CurvePoint;
    s: Field;
}

// Signed raw bytes from the notary
// The signature is over persistentHash(data)
struct SignedBytes {
    data: Bytes<512>;     // Raw attested data (padded to 512 bytes)
    dataLen: Uint<16>;    // Actual length of data before padding
    signature: Signature;
    pk: CurvePoint;       // Notary's public key
}

// ============ Pure Verification Functions ============

// Verify a Schnorr signature over SignedBytes
// Returns true if signature is valid, false otherwise
pure circuit verifySignature(signedData: SignedBytes): Boolean {
    // Compute credential hash: SHA256(data)
    const dataHash: Bytes<32> = persistentHash<Bytes<512>>(signedData.data);

    // Build challenge input: (r, pk, dataHash)
    const challengeInput: ChallengeInput = ChallengeInput {
        r_x: signedData.signature.r.x,
        r_y: signedData.signature.r.y,
        pk_x: signedData.pk.x,
        pk_y: signedData.pk.y,
        credentialHash: dataHash
    };

    // Compute challenge: c = SHA256(challengeInput) mod field_order
    const c: Field = degradeToTransient(persistentHash<ChallengeInput>(challengeInput));

    // Verify Schnorr equation: s * G == r + c * pk
    const lhs: CurvePoint = ecMulGenerator(signedData.signature.s);
    const c_pk: CurvePoint = ecMul(signedData.pk, c);
    const rhs: CurvePoint = ecAdd(signedData.signature.r, c_pk);

    return lhs == rhs;
}

// Assert that a signature is valid (throws if invalid)
pure circuit assertValidSignature(signedData: SignedBytes): [] {
    assert(verifySignature(signedData), "Invalid notary signature");
}

// Verify signature and return the verified data
pure circuit verifyAndExtract(signedData: SignedBytes): Bytes<512> {
    assertValidSignature(signedData);
    return signedData.data;
}
}
